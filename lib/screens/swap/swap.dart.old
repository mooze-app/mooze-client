import 'dart:async';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mooze_mobile/models/asset_catalog.dart';
import 'package:mooze_mobile/models/assets.dart';
import 'package:mooze_mobile/models/sideswap.dart';
import 'package:mooze_mobile/providers/sideswap_repository_provider.dart';
import 'package:mooze_mobile/providers/wallet/liquid_provider.dart';
import 'package:mooze_mobile/screens/swap/widgets/market_selector.dart';
import 'package:mooze_mobile/widgets/appbar.dart';
import 'package:mooze_mobile/widgets/buttons.dart';

class QuoteRequest {
  String baseAsset;
  String quoteAsset;
  String assetType;
  int amount;
  SwapDirection direction;
  List<SwapUtxo> utxos;
  String receiveAddress;
  String changeAddress;

  QuoteRequest({
    required this.baseAsset,
    required this.quoteAsset,
    required this.assetType,
    required this.amount,
    required this.direction,
    required this.utxos,
    required this.receiveAddress,
    required this.changeAddress,
  });
}

class SwapScreen extends ConsumerStatefulWidget {
  const SwapScreen({super.key});

  @override
  ConsumerState<SwapScreen> createState() => SwapScreenState();
}

class SwapScreenState extends ConsumerState<SwapScreen> {
  TextEditingController _amountController = TextEditingController();
  Asset? _selectedSellAsset;
  Asset? _selectedBuyAsset;
  SideswapMarket? _selectedMarket;
  double? _expectedReceiveAmount;
  bool _isLoadingQuote = false;

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    _amountController.dispose();
    super.dispose();
  }

  void loginToSideswap() {
    final sideswapRepository = ref.read(sideswapRepositoryProvider);
    sideswapRepository.init();
  }

  void _onAssetsSelected(
    Asset sellAsset,
    Asset buyAsset,
    SideswapMarket market,
  ) {
    setState(() {
      _selectedSellAsset = sellAsset;
      _selectedBuyAsset = buyAsset;
      _selectedMarket = market;
      _expectedReceiveAmount = null; // Reset when assets change
    });

    // Update SwapNotifier
    final swapNotifier = ref.read(swapNotifierProvider.notifier);
    swapNotifier.setAssets(fromAsset: sellAsset, toAsset: buyAsset);

    // Set direction based on which asset is being sold
    final isSellAssetLBTC = sellAsset.id == "lbtc";
    swapNotifier.setDirection(
      isSellAssetLBTC ? SwapDirection.sell : SwapDirection.buy,
    );
  }

  Future<void> _requestQuote() async {
    if (_selectedSellAsset == null ||
        _selectedBuyAsset == null ||
        _selectedMarket == null ||
        _amountController.text.isEmpty) {
      return;
    }

    final amount = double.tryParse(_amountController.text);
    if (amount == null || amount <= 0) return;

    setState(() {
      _isLoadingQuote = true;
      _expectedReceiveAmount = null;
    });

    try {
      final swapNotifier = ref.read(swapNotifierProvider.notifier);
      swapNotifier.setAmount(amount);

      // Get the current state by reading from the provider
      final swapState = ref.read(swapNotifierProvider);

      // Create a temp subscription to listen for quote responses
      final repository = ref.read(sideswapRepositoryProvider);
      final subscription = repository.quoteResponseStream.listen((
        quoteResponse,
      ) {
        if (quoteResponse.isLowBalance) {
          // Extract the expected amount from low balance response
          final lowBalance = quoteResponse.lowBalance!;

          // Convert from smallest units to display units
          double receiveAmount;
          if (swapState.direction == SwapDirection.sell) {
            // If selling, we'll receive quote_amount
            receiveAmount =
                lowBalance.baseAmount / pow(10, _selectedBuyAsset!.precision);
          } else {
            // If buying, we'll receive base_amount
            receiveAmount =
                lowBalance.quoteAmount / pow(10, _selectedBuyAsset!.precision);
          }

          setState(() {
            _expectedReceiveAmount = receiveAmount;
            _isLoadingQuote = false;
          });
        } else if (quoteResponse.isError) {
          setState(() {
            _isLoadingQuote = false;
          });
          // Show error message
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text("Error: ${quoteResponse.error!.errorMessage}"),
            ),
          );
        }
      });

      // Send quote request with empty UTXOs
      final receiveAddress =
          await ref
              .watch(liquidWalletNotifierProvider.notifier)
              .generateAddress();
      final changeAddress =
          await ref
              .watch(liquidWalletNotifierProvider.notifier)
              .generateAddress();

      if (receiveAddress == null || changeAddress == null) {
        throw Exception("Failed to generate addresses");
      }

      repository.startQuote(
        baseAsset:
            "6f0279e9ed041c3d710a9f57d0c02928416460c4b722ae3457a11eec381c526d", //_selectedMarket!.baseAssetId,
        quoteAsset:
            "02f22f8d9c76ab41661a2729e4752e2c5d1a263012141b86ea98af5472df5189", //  _selectedMarket!.quoteAssetId,
        assetType:
            swapState.direction == SwapDirection.sell
                ? (_selectedSellAsset!.liquidAssetId ==
                        _selectedMarket!.baseAssetId
                    ? "Base"
                    : "Quote")
                : (_selectedBuyAsset!.liquidAssetId ==
                        _selectedMarket!.baseAssetId
                    ? "Base"
                    : "Quote"),
        amount: (amount * pow(10, _selectedSellAsset!.precision)).toInt(),
        direction: swapState.direction,
        utxos: [], // Empty UTXO list to get a quote without actual inputs
        receiveAddress: receiveAddress,
        changeAddress: changeAddress,
      );

      // Cleanup subscription after a timeout
      Future.delayed(const Duration(seconds: 5), () {
        subscription.cancel();
        if (_isLoadingQuote) {
          setState(() {
            _isLoadingQuote = false;
          });
        }
      });
    } catch (e) {
      setState(() {
        _isLoadingQuote = false;
      });

      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text("Failed to get quote: $e")));
    }
  }

  @override
  Widget build(BuildContext context) {
    loginToSideswap();

    return Scaffold(
      appBar: MoozeAppBar(title: "Swap"),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              MarketSelector(onAssetsSelected: _onAssetsSelected),

              if (_selectedSellAsset != null &&
                  _selectedBuyAsset != null &&
                  _selectedMarket != null) ...[
                const SizedBox(height: 24),
                TextField(
                  controller: _amountController,
                  decoration: InputDecoration(
                    labelText: "Quantidade de ${_selectedSellAsset!.name}",
                    suffixText: _selectedSellAsset!.ticker,
                  ),
                  keyboardType: const TextInputType.numberWithOptions(
                    decimal: true,
                  ),
                  onChanged: (_) {
                    // Clear existing quote when amount changes
                    setState(() {
                      _expectedReceiveAmount = null;
                    });
                  },
                ),
                const SizedBox(height: 8),
                ElevatedButton(
                  onPressed: _isLoadingQuote ? null : _requestQuote,
                  child:
                      _isLoadingQuote
                          ? const CircularProgressIndicator(strokeWidth: 2)
                          : const Text("Obter Cotação"),
                ),

                if (_expectedReceiveAmount != null) ...[
                  const SizedBox(height: 16),
                  Card(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "Você receberá aproximadamente:",
                            style: TextStyle(
                              fontFamily: "roboto",
                              fontSize: 20,
                            ),
                          ),
                          const SizedBox(height: 8),
                          Row(
                            children: [
                              Image.asset(
                                _selectedBuyAsset!.logoPath,
                                width: 24,
                                height: 24,
                              ),
                              const SizedBox(width: 8),
                              Text(
                                "${_expectedReceiveAmount!.toStringAsFixed(_selectedBuyAsset!.precision)} ${_selectedBuyAsset!.ticker}",
                                style: TextStyle(
                                  fontFamily: "roboto",
                                  fontSize: 24,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () {
                      // Here you would navigate to the confirmation screen
                      // or proceed with the actual swap
                    },
                    child: const Text("Continuar com Swap"),
                  ),
                ],
              ],
            ],
          ),
        ),
      ),
    );
  }
}
